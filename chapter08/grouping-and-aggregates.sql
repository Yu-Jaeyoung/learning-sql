SET search_path TO sakila, public;

-- Grouping and Aggregates
-- Grouping Concepts

-- Sometimes you will want to find trends in your data that will require the database sever
-- to cook the data a bit before you can generate the results you are looking for
SELECT customer_id
  FROM rental;

-- it isn't feasible to determine which customers have rented the most films by looking at the raw data
-- Instead, you can ask the database server to group the data for you by using the group by clause.
SELECT customer_id
  FROM rental
 GROUP BY customer_id;

-- To see how many films each customer rented,
-- you can use an aggregate function in the select clause to count the number of rows in each group
SELECT customer_id
     , COUNT(*)
  FROM rental
 GROUP BY customer_id;
-- The aggregate function count() counts the number of rows in each group,
-- and the asterisk tells the server to count everything in the group.

SELECT customer_id
     , COUNT(*)
  FROM rental
 GROUP BY customer_id
 ORDER BY 2 DESC;

-- When grouping data, you may need to filter out undesired data from your result set
-- based on groups of data rather than based on the raw data.
-- Since the group by clause runs after the where clause has been evaluated,
-- you cannot add filter conditions to your where clause for this purpose.


--  ERROR: aggregate functions are not allowed in WHERE
SELECT customer_id
     , COUNT(*)
  FROM rental
--  WHERE COUNT(*) >= 40
 GROUP BY customer_id;

-- You cannot refer to the aggregate function count(*) in your where clause,
-- because the groups have not yet been generated at the time the where clause is evaluated
-- Instead, you must put the group filter condition in the having clause.

SELECT customer_id
     , COUNT(*)
  FROM rental
 GROUP BY customer_id
HAVING COUNT(*) >= 40;


-- Aggregate Functions
-- max(), min(), avg(), sum(), count()

SELECT MAX(amount) max_amt
     , MIN(amount) min_amt
     , AVG(amount) avg_amt
     , SUM(amount) tot_amt
     , COUNT(*)    num_payments
  FROM payment;

-- Implicit Versus Explicit Groups
-- In the previous example, every value returned by the query is generated by an
-- aggregate function. Since there is no group by clause, there is a single, implicit group.

-- In most cases, however, you will want to retrieve additional columns along with columns
-- generated by aggregate functions. What if, for example, you wanted to extend the previous
-- query to execute the same five aggregate functions for each customer, instead of across all customers?

-- While it may be obvious to you that you want the aggregate functions applied to each customer
-- found in the payment table, this query fails because you have not explicitly specified
-- how the data should be grouped. Therefore, you will need to add a group by clause to
-- specify over which group of rows the aggregate functions should be applied:
SELECT customer_id
     , MAX(amount) max_amt
     , MIN(amount) min_amt
     , AVG(amount) avg_amt
     , SUM(amount) tot_amt
     , COUNT(*)    num_payments
  FROM payment
 GROUP BY customer_id;

-- Counting Distinct Values
-- When using the count() function to determine the number of members in each group,
-- you have your choice of counting all members in the group or
-- counting only the distinct values for a column across all members of the group

SELECT COUNT(customer_id)          num_rows
     , COUNT(DISTINCT customer_id) num_customer
  FROM payment;
-- The first column in the query simply counts the number of rows in the payment table,
-- whereas the second column examines the values in the customer_id column and counts
-- only the number of unique values.

-- Using Expressions
-- Along with using columns as arguments to aggregate functions, you can use expressions as well.
SELECT MAX(return_date - rental_date)
  FROM rental;

SELECT EXTRACT(DAY FROM MAX(return_date - rental_date))
  FROM rental;

SELECT DATE_PART('day', MAX(return_date - rental_date))
  FROM rental;

-- How Nulls Are Handled
-- When performing aggregations, or indeed, any type of numeric calculation,
-- you should always consider how null values might affect the outcome of your calculation.

CREATE TABLE number_tbl
(
  val SMALLINT
);

INSERT
  INTO number_tbl
VALUES (1)
     , (3)
     , (5);

SELECT COUNT(*)   num_rows
     , COUNT(val) num_vals
     , SUM(val)   total
     , MAX(val)   max_val
     , AVG(val)   avg_val
  FROM number_tbl;

-- add null value to the number_tbl table and run the query again.
INSERT
  INTO number_tbl
VALUES (NULL);
SELECT COUNT(*)   num_rows
     , COUNT(val) num_vals
     , SUM(val)   total
     , MAX(val)   max_val
     , AVG(val)   avg_val
  FROM number_tbl;

-- even with the addition of the null value to the table,
-- the sum(), max(), and avg() functions all return the same values,
-- indicating that they ignore any null values encountered.
-- the count(*) function now returns the value 4, which is valid since
-- the number_tbl table contains four rows, while the count(val) function
-- still returns the value 3.
-- The difference is that count(*) counts the number of rows,
-- whereas count(val) counts the number of values contained in the val column
-- and ignores any null values encountered.

-- Generating Groups
-- Single-Column Grouping
-- Single-column groups are the simplest and most-often-used type of grouping.
-- If you want to find the number of films associated with each actor,
-- for example, you need only group on the film_actor.actor_id column, as in:
SELECT actor_id
     , COUNT(*)
  FROM film_actor
 GROUP BY actor_id;

-- Multicolumn Grouping
-- In some cases, you may want to generate groups that span more than one column.
SELECT fa.actor_id
     , f.rating
     , COUNT(*)
  FROM film_actor fa
       INNER JOIN film f ON fa.film_id = f.film_id
 GROUP BY fa.actor_id
        , f.rating
 ORDER BY 1
        , 2;

-- Grouping via Expressions
-- Along with using columns to group data, you can build groups based on the values
-- generated by expressions. Consider the following query, which groups rentals by year:
SELECT EXTRACT(YEAR FROM rental_date) AS year
     , COUNT(*)                          how_many
  FROM rental
 GROUP BY EXTRACT(YEAR FROM rental_date);


-- Generating Rollups
-- along with the total count for each actor/rating combination,
-- you also want total counts for each distinct actor.
SELECT fa.actor_id
     , f.rating
     , COUNT(*)
  FROM film_actor fa
       INNER JOIN film f ON fa.film_id = f.film_id
 GROUP BY ROLLUP (fa.actor_id
     , f.rating)
 ORDER BY 1
        , 2;

-- Default behavior of ORDER BY in PostgreSQL:
--
-- ASC (Ascending): NULLs appear last (Defaults to NULLS LAST)
-- DESC (Descending): NULLs appear first (Defaults to NULLS FIRST)

SELECT fa.actor_id
     , f.rating
     , COUNT(*)
  FROM film_actor fa
       INNER JOIN film f ON fa.film_id = f.film_id
 GROUP BY ROLLUP (fa.actor_id
     , f.rating)
 ORDER BY fa.actor_id NULLS FIRST
        , f.rating NULLS FIRST;

-- use cube
SELECT fa.actor_id
     , f.rating
     , COUNT(*)
  FROM film_actor fa
       INNER JOIN film f ON fa.film_id = f.film_id
 GROUP BY CUBE (fa.actor_id
     , f.rating)
 ORDER BY fa.actor_id NULLS FIRST
        , f.rating NULLS FIRST;

-- Combinations generated by ROLLUP(actor_id, rating):
-- (actor_id, rating)  -- Individual combinations
-- (actor_id, NULL)    -- Subtotal by actor_id
-- (NULL, NULL)        -- Grand total

-- Combinations generated by CUBE(actor_id, rating):
-- (actor_id, rating)  -- Individual combinations
-- (actor_id, NULL)    -- Subtotal by actor_id
-- (NULL, rating)      -- Subtotal by rating â† Added!
-- (NULL, NULL)        -- Grand total

-- Group Filter Conditions
-- When grouping data, you also can apply filter conditions to the data
-- after groups have been generated. The having clause is where you
-- should place these types of filter conditions.

SELECT fa.actor_id
     , f.rating
     , COUNT(*)
  FROM film_actor fa
       INNER JOIN film f ON fa.film_id = f.film_id
 WHERE f.rating IN ('G', 'PG')
 GROUP BY fa.actor_id
        , f.rating
HAVING COUNT(*) > 9;

-- This query has two filter conditions:
-- one in the where clause, which filters out any films rated something other than G or PG,
-- and another in the having clause, which filters out any actors who appeared in less than 10 films.
-- Thus, one of the filters acts on data before it is grouped, and the other filter acts on data
-- after the groups have been created.


-- Exercise
-- Construct a query that counts the number of rows in the payment table.
SELECT COUNT(*)
  FROM payment;

-- Modify your query from below, to count the number of payments made by each customer.
-- Show the customer ID and the total amount paid for each customer.
SELECT customer_id
     , COUNT(*)
     , SUM(amount)
  FROM payment
 GROUP BY customer_id;

-- Modify your query from below, to include only those customers who have made at least 40 payments
SELECT customer_id
     , COUNT(*)
     , SUM(amount)
  FROM payment
 GROUP BY customer_id
HAVING COUNT(*) >= 40;





